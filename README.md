# Trinoise
A mathematical noise pattern of 3 values based on Number Theory and Set Theory

### Example

The signature of `4` is a list of 108 numbers in base 3:

```text
[1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 0, 1, 0, 1, 2, 0, 1, 0, 1, 0, 1, 2, 0, 1, 0, 1, 0, 1, 2,
 0, 1, 2, 0, 1, 2, 0, 1, 0, 1, 0, 1, 2, 0, 1, 0, 1, 0, 1, 2, 0, 1, 0, 1, 0, 1, 2, 0, 1, 2, 0,
 1, 2, 0, 1, 0, 1, 0, 1, 2, 0, 1, 0, 1, 0, 1, 2, 0, 1, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1,
 0, 1, 0, 1, 2, 0, 1, 0, 1, 0, 1, 2, 0, 1, 0]
```

This signature is mathematically generated based on Number Theory and Set Theory.

A signature can be used to enumerate more efficiently through a collection
which is similar to the powerset operator in Set Theory, but also includes isomorphisms.
The property that is more efficient to search for, is how many modifications are required
to change an identity map into a specific configuration.

### Properties

- Assigns a value to every natural number
- Fixed interpretation based on aligned positions to identity map
- Value counts the number of successors with decreasing value
- Never repeats the same number twice for bases greater than `2`
- Repeats noise pattern after `N^N` for base `N`

The value counts the number of successors with decrementing value.
One can use it to skip successors and project into 3 values:

0. `0`
1. `base - 2`
2. `base - 1`

This is done using the `tri` function.

The frequencies of `0`, `1` and `2` is predictable, e.g.
`[470, 470, 155]` for base `5`.

The frequency of `0` and `1` are equal for bases greater than `2` (conjecture).

The frequency of `0` or `1` divided by frequency of `2` converges rapidly
to `base - 2` when `base` goes to infinity (conjecture).

### Inspiration

The powerset operator is important in Set Theory.
To generate the powerset of a finite set, one can use a binary encoding,
where each bit represents a membership of an object.

One problem with the powerset operator,
is that it does not provide information about isomorphisms of sets
to themselves.

An isomorphism can be modeled as a permutation of an identity map.

For example, `[0, 1, 2, 3]` is isomorphic to `[3, 2, 1, 0]`.

Since a set is unordered, there is only one set for all isomorphisms of the set.

This extra information is desirable when studying equivalences.
Therefore, one would like a more "powerful" way of generating sets.
Instead of generating the sets directly, one wishes to perform an intermediate step,
such that the sets are generated by modifying the data in the intermediate step.

There is a different way of generating sets that respects isomorphisms:

- Starting with an identity map `[0, 1, 2, ..., n-1]`
- Modify one position at a time, e.g. `[0, 1, 2] => [0, 0, 2]` where `1 => 0`
- A modification can use any number from `0` to `n-1`
- The generated discrete combinatorial space forms a groupoid
- Redundant members are removed through post-filtering to form subsets

For example, `[0, 0, 0]` becomes a set which contains only `{0}`.

Isomorphisms are also generated, e.g. `[2, 0, 1]`, not just `[0, 1, 2]`.
This is because every isomorphism is covered by some sequence of modifications,
starting from the identity map. Sometimes, a modification leads to a smaller subset,
but a second modification can lead to an isomorphism of a larger subset than previous step.

For a `n=3`, all lists `[0, 0, 0]` up to `[2, 2, 2]` are generated by modifications.
Therefore, ignoring how these are connected by modifications,
one can simply enumerate all numbers from `0` to `n^n` and interpret them in base `n`.

This means that the same method construct both subsets and isomorphisms.
The combination of subsets and isomorphisms is interesting to study for
[Sized Type Theory](https://github.com/advancedresearch/path_semantics/blob/master/sequences.md#sized-type-theory),
a type theory where functions can be applied to equivalences.
It is believed that an equivalence can ensure the existence of a
partial normal path, hence not require the function to be an isomorphism.

For example, `[0, 0, 1]` is mapped differently than `[1, 0, 0]`, but both has
the same set `{0, 1}`.
When a function maps to a smaller set, it can not be an isomorphism,
but in Sized Type Theory one can use `f(a ~= b) == (f(a) ~= f(b))`,
so this is still meaningful as
existence of some normal path `f[g_i->n]` where `g_i(a) == g_i(b)` and
`g_n(f(a)) == g_n(f(b))`.
Normal paths are commutative squares of functions.
In this case, the square commutes by definition.

One benefit of this groupoid structure, is that it represents all possible
transformations of sets closed under the category of functions.
It is much easier to study this structure than reasoning about families of functions,
because in families of functions the sets are repeated many times.

It turns out that the reachability tree with identity map as root,
assigns a node depth equal to `n` minus aligned positions with identity map.
This makes sense, because when a position is aligned, no modification is required at that position.
The smallest number of modifications needed to go from the identity map to the target,
is determined by the depth of the reachability tree.

All nodes in same node depth in the reachability tree have same number of aligned positions.
This is because aligned positions are those positions that are unaffected by modifications.
Since the node depth is `n - aligned`, and `n` is constant, one can use `aligned`
instead of node depth.

When ordering the reachability tree, which is the same as counting from `0` to `n^n`,
the nodes of same node depth are broken up into smaller neighborhoods.

A neighborhood are some numbers in incrementing sequence with same amount of aligned positions.

The size of the local neighborhood, when counting, is always
`1`, `n - 1` or `n` (conjecture).

This is because when counting upwards, the following is true:

- For every `n` cycle, there is at least one disruption (change of an aligned position)
- Any disruption can either collapse 2 positions, swap 1 vs 1, or collapse 1
- Swapping 1 vs 1 never happens twice during an `n` cycle

The intuition is that if the least significant digit is aligned,
then incrementing makes it no longer aligned.
This leads to a change in amount of aligned positions, unless the reminder
incidentally aligns the second least significiant digit.
When this case occurs, where one aligned position is swapped for another,
one calls it "swap 1 vs 1".
This can never happen twice during an `n` cycle.

Although this proves that local neighborhoods are not greater than `n`,
it does not prove why there are `1`, `n - 1` or `n` as the only valid solutions.

The order of the identity map is chosen to preserve this property.
If one uses `210` instead of `012` in base `3`, this property is destroyed.
This is because one gets a different reachability tree.

The nodes in the groupoid can naturally be encoded with numbers in base `n`.
In base `n`, the signature of ordered neighborhoods with same node depth
is encodable in base `n` by subtracting `1`, counting successors
from the first node in a local neighborhood.
Therefore, `0`, `base - 2` or `base - 1` are the only values.

Since there are only 3 values,
one can use `0, 1, 2` (base `3`) to represent the signature.
This is what becomes the trinoise.

### Geometric Interpretation

If one thinks about the identity map `[0, 1, 2, ..., n-1]` as a center,
then a sequence of single modification by replacing numbers with `0` to `n-1`
can be though of as having a radius to the center.

A such measurement on a space is called a [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance).

If the starting point was `[n/2, n/2, n/2, ..., n/2]`,
then the shape of a grid normalized to a space with Hamming distance
forms a [Hamming N-Sphere](https://github.com/advancedresearch/path_semantics/blob/master/papers-wip/hamming-n-sphere.pdf).

However, since one starts with the identity map,
the Hamming distance is skewed by the order of dimensions.

A signature is a fragmentation of the skewed Hamming N-Sphere
onto the sequence of natural numbers.
It is not possible to enumerate all points of equal Hamming distance directly,
but requires checking the aligned positions of the first number.

Therefore, trinoise signatures have no direct intuitive geometric interpretation.
Although, it might happen that this application of geometry is useful for Number Theory.
